name: Build and Deploy

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# Secrets hardcoded in YAML
# No environment separation
# No test failure blocking deploy
# Missing caching
# No linting step
# Poor error handling

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        # No caching for node_modules
    
    - name: Install dependencies
      run: npm install
      # No error handling - continues even if fails
    
    - name: Build application
      run: npm run build
      # No error handling
      # No build artifacts caching
    
    - name: Build Docker image
      run: |
        docker build -t myapp:${{ github.sha }} .
        docker tag myapp:${{ github.sha }} myapp:latest
      # Insecure Docker image usage - no image scanning
      # Hardcoded image name
    
    - name: Push to registry
      run: |
        echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
        docker push myapp:${{ github.sha }}
        docker push myapp:latest
      # Hardcoded registry credentials in workflow
      # No error handling for login failure

  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        # No caching
    
    - name: Install dependencies
      run: npm install
      # No error handling
    
    - name: Run tests
      run: npm test
      continue-on-error: true  # No test failure blocking deploy
      # Tests can fail but deployment continues
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: test-results/
      # No error handling

  deploy:
    needs: [build, test]  # Depends on test but test can fail
    runs-on: ubuntu-latest
    # No environment separation - deploys to same environment always
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to production
      run: |
        # Hardcoded secrets in script
        export AWS_ACCESS_KEY_ID="AKIAIOSFODNN7EXAMPLE"
        export AWS_SECRET_ACCESS_KEY="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
        export DB_PASSWORD="hardcoded_password_123"
        export API_KEY="sk_live_1234567890abcdef"
        
        # No environment separation
        # Deploys to production regardless of branch
        ./scripts/deploy.sh production
      # Poor error handling - no try/catch
      # No rollback strategy
    
    - name: Health check
      run: |
        sleep 10
        curl -f http://production.example.com/health || true
      # Poor error handling - || true ignores failures
      # No rollback if health check fails

